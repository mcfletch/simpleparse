'''Default SimpleParse EBNF grammar as a generator with productions

This module defines the original SimpleParse
grammar.  It uses the generator objects directly
as this is the first grammar being written.
'''
#from copy import copy
import functools as ft
from simpleparse.objectgenerator import *
from simpleparse import generator, baseparser
from simpleparse.dispatchprocessor import *


# note that whitespace is slightly different
# due to a bug with NULL-matching repeating groups
# we make all the ts references ts?
whitespace = Name (value = "ts", report = 0)
element_token = Name( value = "element_token" )
literal = Name ( value = "literal")
group = Name ( value = "group")
characterrange = Name ( value = "range")
name = Name ( value = "name")

# Note: Changes due to discrepancies between actual ebnf grammar definition and
# declaration string corrected to facilitate direct comparison between
# actual implementation and product generated by SPGrammarProcessor(Bytes|Str)
# Otherwise testing of the latter without risking side effects by errors inside
# parser is not possible

SPGenerator = generator.Generator ()
SPGenerator.addDefinition(
    "declarationset",
    Name (value = "declaration", repeating = 1),
)



SPGenerator.addDefinition (
    "declaration",
    SequentialGroup (
        children = [
            whitespace,
            FirstOfGroup (
                children = [
                    Name (value = "unreportedname", ),
                    Name (value = "expandedname", ),
                    Name (value = "name", ),
                ],
            ),
            whitespace,
            Literal (value = b":"),
            Literal (value = b":", optional=1),
            Literal (value = b"=",),
            Name( value = "seq_group"),
        ],
    )
)

SPGenerator.addDefinition (
    "group",
    SequentialGroup (
        children = [
            Literal (value =b"("),
            Name( value= "seq_group"),
            Literal (value =b")"),
        ],
        expanded = 1,
    )
)

_seq_children = FirstOfGroup(
    children = [
        Name(value="error_on_fail"),
        Name(value="fo_group"),
        Name(value="element_token"),
    ],
)

SPGenerator.addDefinition (
    "seq_group",
    SequentialGroup (
        children = [
            whitespace,
            _seq_children,
            SequentialGroup(
                children = [
                    whitespace,
                    Name( value="seq_indicator"),
                    whitespace,
                    _seq_children,
                ],
                repeating = 1, optional = 1,
            ),
            whitespace,
        ],
    ),
)

SPGenerator.addDefinition (
    "fo_group",
    SequentialGroup (
        children = [
            element_token,
            SequentialGroup(
                children = [
                    whitespace,
                    Name( value="fo_indicator"),
                    whitespace,
                    element_token,
                ],
                repeating = 1,
            ),
        ],
    )
)
SPGenerator.addDefinition (
    "seq_indicator",
    Literal(value = b",", report=0 ),
)	
SPGenerator.addDefinition (
    "fo_indicator",
    Literal(value = b"/", report=0 ),
)	

SPGenerator.addDefinition (
    "element_token",
    SequentialGroup (
        children = [
            Name (value = "lookahead_indicator", optional = 1),
            whitespace,
            Name (value = "negpos_indicator", optional = 1),
            whitespace,
            FirstOfGroup (
                children = [
                    literal,
                    characterrange,
                    group,
                    name,
                ]
            ),
            whitespace,
            Name (value = "occurence_indicator", optional = 1),
            whitespace,
            Name (value = "error_on_fail", optional = 1),
        ]
    )
)

SPGenerator.addDefinition (
    "negpos_indicator",
    Range (value = b"-+" ) # another incosistentcy between below and here
)
SPGenerator.addDefinition (
    "lookahead_indicator",
    Literal(value = b"?" ),
)	

SPGenerator.addDefinition (
    "occurence_indicator",
    Range (value = b"+*?" ),
)	
SPGenerator.addDefinition (
    "error_on_fail",
    SequentialGroup (
        children = [
            Literal (value =b"!"),
            SequentialGroup (
                children = [
                    whitespace,
                    Name( value="literal"),
                ],
                optional = 1,
            ),
        ],
    ),
)

SPGenerator.addDefinition (
    "unreportedname",
    SequentialGroup (
        children = [
            Literal (value =b"<"),
            #whitespace, # Any reason why here 'ts' while not in declaration below 
            name,
            #whitespace, # Any reason why here 'ts' while not in declaration below
            Literal (value =b">"),
        ]
    )
)
SPGenerator.addDefinition (
    "expandedname",
    SequentialGroup (
        children = [
            Literal (value =b">"),
            #whitespace, # Any reason why here 'ts' while not in declaration below
            name,
            #whitespace, # Any reason why here 'ts' while not in declaration below
            Literal (value =b"<"),
        ]
    )
)

SPGenerator.addDefinition (
    "name",
    SequentialGroup (
        children = [
            Range(value =b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_'),
            Range(value =b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_', optional= 1, repeating= 1),# underscore is at end in below definition 
        ]
    )
)

SPGenerator.addDefinition (
    "ts", # ( [ \011-\015]+ / ('#',-'\n'+,'\n')+ )*
    FirstOfGroup (
        children = [
            Range(value =b' \011\012\013\014\015', repeating=1),
            Name( value = "comment" ),
        ],
        repeating = 1, optional=1,
    )
)
SPGenerator.addDefinition (
    "comment", # ( [ \011-\015]+ / ('#',-'\n'+,'\n')+ )*
    SequentialGroup (
        children = [
            Literal ( value =b"#"),
            Literal (value =b"\n", negative = 1, repeating = 1, optional=1),
            Literal (value = b"\n",),
        ],
    ),
)

SPGenerator.addDefinition (
    "literalDecorator", # literalDecorator    :=  [c]
    Range( value = b'c' )
)

SPGenerator.addDefinition (
    "literal",  # ("'",(CHARNOSNGLQUOTE/ESCAPEDCHAR)*,"'")  /  ('"',(CHARNODBLQUOTE/ESCAPEDCHAR)*,'"')
    SequentialGroup(
        children = [
            Name( value = 'literalDecorator', optional=1 ),
            FirstOfGroup (
                children = [
                    SequentialGroup (
                        children = [
                            Literal (value =b"'"),
                            FirstOfGroup (
                                children = [
                                    Name (value = "CHARNOSNGLQUOTE"),
                                    Name (value = "ESCAPEDCHAR"),
                                ],
                                optional = 1, repeating = 1,
                            ),
                            Literal (value =b"'"),
                        ],
                    ),
                    SequentialGroup (
                        children = [
                            Literal (value =b'"'),
                            FirstOfGroup (
                                children = [
                                    Name (value = "CHARNODBLQUOTE"),
                                    Name (value = "ESCAPEDCHAR"),
                                ],
                                optional = 1, repeating = 1,
                            ),
                            Literal (value =b'"'),
                        ],
                    )
                ],
            ),
        ],
    )
)

SPGenerator.addDefinition (
    "range",   # '[',CHARBRACE?,CHARDASH?, (CHARRANGE/CHARNOBRACE)*, CHARDASH?,']'
    SequentialGroup (
        children =[
            Literal (value =b"["),
            Name (value ="CHARBRACE",optional = 1),
            Name (value ="CHARDASH",optional = 1),
            FirstOfGroup(
                children = [
                    Name (value ="CHARRANGE"),
                    Name (value ="CHARNOBRACE"),
                ],
                optional = 1, repeating = 1,
            ),
            Name (value ="CHARDASH",optional = 1),
            Literal (value =b"]"),
        ],
    )
)
SPGenerator.addDefinition (
    "CHARBRACE",   
    Literal (value = b"]"),
)
SPGenerator.addDefinition (
    "CHARDASH",   
    Literal (value = b"-"),
)
SPGenerator.addDefinition (
    "CHARRANGE",   # CHARRANGE           :=  CHARNOBRACE, '-', CHARNOBRACE
    SequentialGroup (
        children =[
            Name (value ="CHARNOBRACE"),
            Literal (value =b"-"),
            Name (value ="CHARNOBRACE"),
        ],
    ),
)
SPGenerator.addDefinition (
    "CHARNOBRACE",   # CHARRANGE           :=  CHARNOBRACE, '-', CHARNOBRACE
    FirstOfGroup(
        children =[
            Name (value ="ESCAPEDCHAR"),
            Name (value ="CHAR"),
        ],
    ),
)
SPGenerator.addDefinition (
    "CHAR",
    Literal (
        value =b"]",
        negative = 1,
    ),
)

SPGenerator.addDefinition (
    "ESCAPEDCHAR",   # '\\',( SPECIALESCAPEDCHAR / ('x',HEXESCAPEDCHAR) / UNICODEESCAPEDCHAR_16 / OCTALESCAPEDCHAR /   )
    SequentialGroup (
        children =[
            Literal (value =b"\\"),
            FirstOfGroup(
                children = [
                    Name (value ="SPECIALESCAPEDCHAR"),
                    SequentialGroup(
                        children = [
                            Range( value = b'xX' ),
                            Name( value="HEXESCAPEDCHAR"),
                        ]
                    ),
                    Name (value ="OCTALESCAPEDCHAR"),
                    SequentialGroup(
                        children = [
                            Range( value=b'uU'),
                            Name( value='UNICODEESCAPEDCHAR' ),
                        ],
                    ),
                ],
            ),
        ],
    )
)

SPGenerator.addDefinition (
    "SPECIALESCAPEDCHAR",
    Range(value =b'\\abfnrtv"\''),
)

SPGenerator.addDefinition (
    "OCTALESCAPEDCHAR",   # [0-7],[0-7]?,[0-7]?
    SequentialGroup (
        children =[
            Range (value =b"01234567"),
            Range (value =b"01234567", optional = 1),
            Range (value =b"01234567", optional = 1),
        ],
    )
)
SPGenerator.addDefinition (
    "HEXESCAPEDCHAR",   # [0-9a-fA-F],[0-9a-fA-F]
    SequentialGroup (
        children =[
            Range (value =b"0123456789abcdefABCDEF"),
            Range (value =b"0123456789abcdefABCDEF"),
        ],
    )
)
SPGenerator.addDefinition(
    "UNICODEESCAPEDCHAR",
    SequentialGroup(
        children=[
            Range (value =b"0123456789abcdefABCDEF"),
            Range (value =b"0123456789abcdefABCDEF"),
            Range (value =b"0123456789abcdefABCDEF"),
            Range (value =b"0123456789abcdefABCDEF"),
            SequentialGroup(
                children = [
                    Range (value =b"0123456789abcdefABCDEF"),
                    Range (value =b"0123456789abcdefABCDEF"),
                    Range (value =b"0123456789abcdefABCDEF"),
                    Range (value =b"0123456789abcdefABCDEF"),
                ],
                optional = True,
            )
        ]
    )
)

SPGenerator.addDefinition (
    "CHARNODBLQUOTE",
    Range(value =b'\\"', negative = 1, repeating = 1),
)
SPGenerator.addDefinition (
    "CHARNOSNGLQUOTE",
    Range(value =b"\\'", negative = 1, repeating = 1),
)

declaration = rb"""
# Note: <ebnf> grammar declaration is bytes string. This allows to generate
# parsers for str and bytes input data. Thereby the type of data parasable
# depends upon type of declaration string passed.
# type(declaration) == str   -> parser for processing text (str type) input
# type(declaration) == bytes -> parser for processing binary (bytes type) intput
# 
declarationset      :=  declaration+
declaration         :=  ts, (unreportedname/expandedname/name) ,ts,':',':'?,'=',seq_group

element_token       :=  lookahead_indicator?, ts, negpos_indicator?,ts, (literal/range/group/name),ts, occurence_indicator?, ts, error_on_fail?

negpos_indicator    :=  [-+]
lookahead_indicator :=  "?"
occurence_indicator :=  [+*?]
error_on_fail       :=  "!", (ts,literal)?

>group<             :=  '(',seq_group, ')'
seq_group           :=  ts,(error_on_fail/fo_group/element_token),
                          (ts, seq_indicator, ts,
                              (error_on_fail/fo_group/element_token)
                          )*, ts

fo_group            :=  element_token, (ts, fo_indicator, ts, element_token)+


# following two are likely something peoples might want to
# replace in many instances...
<fo_indicator>      :=  "/"
<seq_indicator>     :=  ','

unreportedname      :=  '<', name, '>'
expandedname        :=  '>', name, '<'
name                :=  [a-zA-Z_],[a-zA-Z0-9_]*
<ts>                :=  ( [ \011-\015]+ / comment )*
comment             :=  '#',-'\n'*,'\n'
literal             :=  literalDecorator?,("'",(CHARNOSNGLQUOTE/ESCAPEDCHAR)*,"'")  /  ('"',(CHARNODBLQUOTE/ESCAPEDCHAR)*,'"')
literalDecorator    :=  [c]



range               :=  '[',CHARBRACE?,CHARDASH?, (CHARRANGE/CHARNOBRACE)*, CHARDASH?,']'
CHARBRACE           :=  ']'
CHARDASH            :=  '-'
CHARRANGE           :=  CHARNOBRACE, '-', CHARNOBRACE
CHARNOBRACE         :=  ESCAPEDCHAR/CHAR
CHAR                :=  -[]]

# Note: declaration must either be defined as raw string (prefix 'r') or '\\' must be
#       entered as '\\\\' to prevent interpretation of escaped char by python
ESCAPEDCHAR         :=  '\\',( SPECIALESCAPEDCHAR / ([xX],HEXESCAPEDCHAR) / OCTALESCAPEDCHAR / ([uU],UNICODEESCAPEDCHAR) )
SPECIALESCAPEDCHAR  :=  [\\abfnrtv"']
OCTALESCAPEDCHAR    :=  [0-7],[0-7]?,[0-7]?
HEXESCAPEDCHAR      :=  [0-9a-fA-F],[0-9a-fA-F]
CHARNODBLQUOTE      :=  -[\\"]+
CHARNOSNGLQUOTE     :=  -[\\']+

# Note: UNICODEESCAPEDCHAR available for str type productions only
UNICODEESCAPEDCHAR  := [0-9a-fA-F],[0-9a-fA-F],[0-9a-fA-F],[0-9a-fA-F],([0-9a-fA-F],[0-9a-fA-F],[0-9a-fA-F],[0-9a-fA-F])?
"""

### Now the interpreter objects...
class Parser(baseparser.BaseParser):
    """Parser which generates new parsers from EBNF grammars

    This parser class allows you to pass in an EBNF grammar as
    the initialisation parameter.  The EBNF is processed, and a
    SimpleParse generator object is created as self.generator.

    Unlike most Parsers, this object is intended to be re-created
    for each bit of data it parses (i.e. each EBNF), so it warps
    the standard API a lot.
    """
    _rootProduction = 'declarationset'
    def __init__( self, ebnf, prebuilts=(), methodSource=None, definitionSources=() ):
        """Create a new generator based on the EBNF in simpleparse format"""
        if isinstance(ebnf,str):
            processor = SPGrammarProcessorStr( prebuilts, definitionSources )
            bytes_ebnf = ebnf.encode('utf8')
        else:
            processor = SPGrammarProcessorBytes( prebuilts, definitionSources )
            bytes_ebnf = ebnf
        success, tags, next = self.parse( bytes_ebnf, self._rootProduction, processor=processor )
        if next != len(bytes_ebnf):
            lineNumber = lines(0, next, ebnf)
            raise ValueError(
                """Unable to complete parsing of the EBNF, stopped at line %s (%s chars of %s)
Unparsed:\n%s..."""%(lineNumber, next, len(ebnf), ebnf[next:next+100])
            )

        self.generator = processor.generator
    def buildTagger( self, name=None, processor = None ):
        """Build the tag-table for parsing the EBNF for this parser"""
        return SPGenerator.buildParser( name, methodSource = processor )

class SPGrammarProcessor( DispatchProcessor ):
    """Processing object for post-processing an EBNF into a new generator"""
    ### top level

    join = None
    encode = encode_ignore = None
    def __init__( self, prebuilts=(), definitionSources=()):
        """Create a new generator based on the EBNF in simpleparse format"""
        self.generator = generator.Generator()
        for (name, table) in prebuilts:
            if isinstance( table, ElementToken):
                self.generator.addDefinition( name, table)
            else:
                self.generator.addDefinition( name, Prebuilt(value=table))
        for source in definitionSources:
            self.generator.addDefinitionSource( source )
    
    def declaration( self, info, buffer):
        '''Base declaration from the grammar, a "production" or "rule"'''
        (tag, left, right, sublist) = info
        name = sublist[0]
        expanded = 0
        if name[0] == "unreportedname":
            name = name[3][0]
            # note that the info is stored in the wrong place :(
            report = 0
        elif name[0] == 'expandedname':
            report = 1
            expanded = 1
            name = name[3][0]
        else:
            report = 1
        name = str(buffer[name[1]:name[2]],'ascii')#getString( name, buffer )
        self.currentProduction = name
        content = dispatch( self, sublist[1], buffer )
        content.report = report
        content.expanded = expanded
        self.generator.addDefinition(
            name,
            content,
        )
        del self.currentProduction

    ### element configuration
    def element_token( self, info, buffer):
        '''get the children, then configure'''
        (tag, left, right, sublist) = info
        base = None
        negative = 0
        optional = 0
        repeating = 0
        lookahead = 0
        errorOnFail = None
        for tup in sublist:
            result = dispatch( self, tup, buffer )
            if tup[0] == 'negpos_indicator':
                negative = result
            elif tup[0] == 'occurence_indicator':
                optional, repeating = result
            elif tup[0] == 'lookahead_indicator':
                lookahead = result
            elif tup[0] == 'error_on_fail':
                # we do some extra work here
                errorOnFail = result
                self._config_error_on_fail( errorOnFail, (tag,left,tup[1],[]), buffer )
            else:
                base = result
        base.optional = optional
        base.negative = negative
        base.repeating = repeating
        base.lookahead = lookahead
        if errorOnFail:
            base.errorOnFail = errorOnFail
        return base

    ### generator-node-builders
    def seq_group( self, info, buffer):
        """Process a sequential-group into a SequentialGroup element token"""
        (tag, left, right, sublist) = info
        children = dispatchList( self, sublist, buffer )
        errorOnFail = None
        result = []
        for (item,tup) in zip(children,sublist):
            if isinstance( item, ErrorOnFail ):
                errorOnFail = item
            else:
                if errorOnFail:
                    item.errorOnFail = errorOnFail.copy()
                    self._config_error_on_fail(
                        item.errorOnFail,
                        tup,
                        buffer
                    )
                result.append( item )
        if len(result) == 1:
            # single-item sequential group (very common)
            return result[0]
        elif not result:
            sofar = self.encode(buffer[:left])
            raise ValueError( """SequentialGroup on line %s doesn't have an element-token child! grammar was %s"""%( lines(0,left, buffer), self.encode_ignore(buffer[left:left+25])))
        base = SequentialGroup(
            children = result,
        )
        return base
    def fo_group( self, info, buffer):
        """Process a first-of-group into a FirstOf element token"""
        (tag, left, right, sublist) = info
        children = dispatchList( self, sublist, buffer )
        if len(children) == 1:
            # this should never happen, but if it does, we can deal with it I suppose...
            return children[0]
        base = FirstOfGroup(
            children = children
        )
        return base
        
    def literal( self, info, buffer):
        '''Turn a literal result into a literal generator'''
        (tag, left, right, sublist) = info
        if sublist and sublist[0][0] == 'literalDecorator':
            # right now only have the one decorator...
            sublist = sublist[1:]
            classObject = CILiteral
        else:
            classObject = Literal
        elements = dispatchList( self, sublist, buffer)
        ### Should check for CILiteral with non-CI string or single-character value!
        return classObject( value = self.join(elements) )

    def range( self, info, buffer):
##		if hasattr( Range, 'requiresExpandedSet') and Range.requiresExpandedSet:
        (tag, left, right, sublist) = info
        return Range(
            value = self.join(dispatchList( self, sublist, buffer)),
        )
##		else:
##			# need to build up a new-syntax version of the range...
##			# escape ^ to \^
##			# escape \ to \\
##			# escape - to \-
##			# make sure range-sets are in proper order...
##			raise NotImplementedError( """Haven't got the new CharSet version implemented yet""")
    def name( self, tup, buffer):
        return Name(
            value = str(buffer[tup[1]:tup[2]],'ascii'), #getString(tup, buffer),
        )
    ### simple translators
    occurenceIndicatorMap = {
        b'*': (1,1),
        b'+': (0,1),
        b'?': (1,0),
    }
    def occurence_indicator( self, tup, buffer):
        '''Return optional, repeating as a tuple of true/false values'''
        value = getString(tup, buffer)
        return self.occurenceIndicatorMap[value]
    def lookahead_indicator( self, tup, buffer ):
        """If present, the lookahead indictor just says "yes", so just return 1"""
        return 1
    def error_on_fail( self, info, buffer ):
        """If present, we are going to make the current object an errorOnFail type,

        If there's a string literal child, then we use it to create the
        "message" attribute of the errorOnFail object.
        """
        (tag,left,right,children) = info
        err = ErrorOnFail()
        if children:
            (tag,left,right,children) = children[0]
            message = self.join(dispatchList( self, children, buffer))
            err.message = message
        return err

    def _config_error_on_fail( self, errorOnFail, tup, buffer ):
        """Configure an error-on-fail instance for a given child tuple"""
        # what we expected to find...
        errorOnFail.expected = self.encode(buffer[tup[1]:tup[2]])
        if hasattr( self, "currentProduction"):
            errorOnFail.production = self.currentProduction
        
    negposIndicatorMap = {
        b'+': 0,
        b'-': 1,
    }
    def negpos_indicator( self, tup, buffer ):
        '''return whether indicates negative'''
        value = getString(tup, buffer)
        return self.negposIndicatorMap[value]

    def ESCAPEDCHAR( self, info, buffer):
        (tag, left, right, sublist) = info
        return self.join(dispatchList( self, sublist, buffer))

    specialescapedmap = {}
    def SPECIALESCAPEDCHAR( self, tup, buffer):
        return self.specialescapedmap[ getString(tup, buffer)]
    def CHARNOBRACE( self, info, buffer):
        (tag, left, right, sublist) = info
        return self.join(dispatchList( self, sublist, buffer))


class SPGrammarProcessorStr(SPGrammarProcessor):
    
    def getString(self,info,buffer):
        return str(buffer[info[1]:info[2]],'utf8')

    join = "".join
    encode_ignore = ft.partial(str,encoding='utf8',errors='ignore')
    encode = ft.partial(str,encoding='utf8',errors='backslashreplace')
    specialescapedmap = {
        b'a':'\a',
        b'b':'\b',
        b'f':'\f',
        b'n':'\n',
        b'r':'\r',
        b't':'\t',
        b'v':'\v',
        b'\\':'\\',
        b'"':'"',
        b"'":"'",
    }

    def CHARNODBLQUOTE( self, tup, buffer):
        try:
            return str(buffer[tup[1]:tup[2]],'utf8')
        except UnicodeDecodeError:
            sofar = buffer[:tup[1]].decode('utf8')
            lineNumber = lines(0, tup[1],buffer)
            seq = buffer[tup[1]]
            if (seq & 0x38) > 0x30 or (seq & 0xC0 != 0xC0 ):
                # anything but a first byte of a valid utf8 multibyte
                raise ValueError("invalid utf8 char '{}' found at line {} ({}): forgot 'r' string flag?\n'{}')".format(seq.decode('utf8','hexencode'),lineNumber,len(sofar.rsplit('\n',1)[-1]),buffer[tup[1]:].decode('utf8','hexencode')))
            remain = buffer[tup[1]:].decode('utf8')
            raise ValueError("utf8 char '{}' not recognized at line {} ({}): forgot 'r' string flag ?\n'{}')".format(remain[1],lineNumber,len(sofar.rsplit('\n',1)[-1]),remain))
    CHAR = CHARNOSNGLQUOTE = CHARNODBLQUOTE

    def CHARDASH( self, tup , buffer):
        return '-'

    def CHARBRACE( self, tup , buffer):
        return ']'

    def UNICODEESCAPEDCHAR( self, info, buffer):
        """Decode a unicode-escaped hex character into a character value"""
        (tag, left, right, sublist) = info
        char = chr(int( buffer[left:right], 16 ))
        return char

    def CHARRANGE( self, info, buffer):
        '''Create a string from first to second item'''
        (tag, left, right, sublist) = info
        first,second = dispatchList( self, sublist, buffer)
        if second < first:
            second, first = first, second
        if type(first) is not type(second):#isinstance( first, str ) or isinstance( second, str ):
            #if not (isinstance( second, str ) and isinstance( first, str )):
            raise ValueError( 'Range %s uses one unicode and one string escape, cannot mix'%(buffer[left:right]) )
        first = ord(first)
        second = ord(second)
        return ''.join(map(chr,range(first,second+1)))

    def OCTALESCAPEDCHAR(self, tup, buffer):
        return chr(int( buffer[tup[1]:tup[2]], 8 ))
    def HEXESCAPEDCHAR( self, tup , buffer):
        return chr(int( buffer[tup[1]:tup[2]], 16 ))


class SPGrammarProcessorBytes(SPGrammarProcessor):

    join = b''.join
    encode = encode_ignore = bytes
    specialescapedmap = {
        b'a':b'\a',
        b'b':b'\b',
        b'f':b'\f',
        b'n':b'\n',
        b'r':b'\r',
        b't':b'\t',
        b'v':b'\v',
        b'\\':b'\\',
        b'"':b'"',
        b"'":b"'",
    }

    def CHARNODBLQUOTE(self,info,buffer):
        (tag, left, right, sublist) = info
        return buffer[left:right]
    CHAR = CHARNOSNGLQUOTE = CHARNODBLQUOTE

    def CHARDASH( self, tup , buffer):
        return b'-'
    def CHARBRACE( self, tup , buffer):
        return b']'
    def CHARRANGE( self, info, buffer):
        '''Create a string from first to second item'''
        (tag, left, right, sublist) = info
        first,second = dispatchList( self, sublist, buffer)
        if second < first:
            second, first = first, second
        first = ord(first)
        second = ord(second)
        #first, #second = list(map( ord, (first,second) ))
        # TODO might not work as such
        #return b''.join([_chr(u) for u in range(first,second+1)])
        return bytes(range(first,second+1))

    def OCTALESCAPEDCHAR(self, tup, buffer):
        return bytes((int( buffer[tup[1]:tup[2]], 8 ),))
    def HEXESCAPEDCHAR( self, tup , buffer):
        return bytes((int( buffer[tup[1]:tup[2]], 16 ),))

    def UNICODEESCAPEDCHAR( self, info, buffer):
        raise ValueError( "Unicode escape '%s': not valid for bytes productions"%(buffer[info[1]:info[2]]) )
